use super::types::*;
use super::lexer::{Token, LexicalError};

grammar<'input>(input: &'input str);

pub Source: Block = {
    Expression => Block(<>)
}

Expression: Expr = {
    Expr0,
}

Expr0: Expr = {
    <l:Expr0> <a:@L> "+" <b:@R> <r:Expr1> => Expr::Add(Loc(a, b), Box::new(l), Box::new(r)),
    <l:Expr0> <a:@L> "-" <b:@R> <r:Expr1> => Expr::Subtract(Loc(a, b), Box::new(l), Box::new(r)),
    Expr1,
}

Expr1: Expr = {
    <l:Expr1> <a:@L> "*" <b:@R> <r:Expr2> => Expr::Multiply(Loc(a, b), Box::new(l), Box::new(r)),
    <l:Expr1> <a:@L> "/" <b:@R> <r:Expr2> => Expr::Divide(Loc(a, b), Box::new(l), Box::new(r)),
    Expr2,
}

Expr2: Expr = {
    <l:Expr2> <a:@L> "**" <b:@R> <r:Expr3> => Expr::Power(Loc(a, b), Box::new(l), Box::new(r)),
    Expr3,
}

Expr3: Expr = {
    <a:@L> "-" <b:@R> <r:Expr3> => Expr::UnaryMinus(Loc(a, b), Box::new(r)),
    <a:@L> <s:LexStringLiteral> <b:@R> => Expr::StringLiteral(Loc(a, b), s.to_string()),
    "(" <e:Expression> ")" => e,
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        LexStringLiteral => Token::String(<&'input str>),
        // "pi" => Token::Pi,
        "+" => Token::OpAdd,
        "-" => Token::OpSub,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "**" => Token::OpPow,
        "(" => Token::ParenOpen,
        ")" => Token::ParenClose,
    }
}
