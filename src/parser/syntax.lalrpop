use super::terms::*;
use super::lexer::{Token, LexicalError};

grammar<'input>(input: &'input str);

// templates
SepVec<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Source: Statements = {
    SepVec<Statement> => Statements(<>),
}

Statement: Statement = {
    Expression => Statement(<>),
}

Expression: Term = {
    Expr0,
}

Expr0: Term = {
    <l:Expr0> <a:@L> "+" <b:@R> <r:Expr1> => Term::Add(Loc(a, b), Box::new(l), Box::new(r)),
    <l:Expr0> <a:@L> "-" <b:@R> <r:Expr1> => Term::Subtract(Loc(a, b), Box::new(l), Box::new(r)),
    Expr1,
}

Expr1: Term = {
    <l:Expr1> <a:@L> "*" <b:@R> <r:Expr2> => Term::Multiply(Loc(a, b), Box::new(l), Box::new(r)),
    <l:Expr1> <a:@L> "/" <b:@R> <r:Expr2> => Term::Divide(Loc(a, b), Box::new(l), Box::new(r)),
    Expr2,
}

Expr2: Term = {
    <l:Expr2> <a:@L> "**" <b:@R> <r:Expr3> => Term::Power(Loc(a, b), Box::new(l), Box::new(r)),
    Expr3,
}

Expr3: Term = {
    <a:@L> "-" <b:@R> <r:Expr3> => Term::UnaryMinus(Loc(a, b), Box::new(r)),
    <a:@L> <s:LexNumberLiteral> <b:@R> => {
        Term::NumberLiteral(Loc(a, b), s.parse::<i128>().unwrap())
    },
    "(" <e:Expression> ")" => e,
    <a:@L> "PI" <b:@R> => Term::Pi(Loc(a, b)),
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        LexVariable => Token::Variable(<&'input str>),
        LexNumberLiteral => Token::Number(<&'input str>),
        "+" => Token::OpAdd,
        "-" => Token::OpSub,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "**" => Token::OpPow,
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
        ";" => Token::Semicolon,
        "PI" => Token::Pi,
    }
}
