use super::terms::*;
use super::lexer::{Token, LexicalError};

grammar<'input>(input: &'input str);

pub Source: Block = {
    Expression => Block(<>),
}

Expression: Term = {
    Expr0,
}

Expr0: Term = {
    <l:Expr0> <a:@L> "+" <b:@R> <r:Expr1> => Term::Add(Loc(a, b), Box::new(l), Box::new(r)),
    <l:Expr0> <a:@L> "-" <b:@R> <r:Expr1> => Term::Subtract(Loc(a, b), Box::new(l), Box::new(r)),
    Expr1,
}

Expr1: Term = {
    <l:Expr1> <a:@L> "*" <b:@R> <r:Expr2> => Term::Multiply(Loc(a, b), Box::new(l), Box::new(r)),
    <l:Expr1> <a:@L> "/" <b:@R> <r:Expr2> => Term::Divide(Loc(a, b), Box::new(l), Box::new(r)),
    Expr2,
}

Expr2: Term = {
    <l:Expr2> <a:@L> "**" <b:@R> <r:Expr3> => Term::Power(Loc(a, b), Box::new(l), Box::new(r)),
    Expr3,
}

Expr3: Term = {
    <a:@L> "-" <b:@R> <r:Expr3> => Term::UnaryMinus(Loc(a, b), Box::new(r)),
    <a:@L> <s:LexNumberLiteral> <b:@R> => {
        Term::NumberLiteral(Loc(a, b), s.parse::<i128>().unwrap())
    },
    "(" <e:Expression> ")" => e,
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        LexStringLiteral => Token::Variable(<&'input str>),
        LexNumberLiteral => Token::Number(<&'input str>),
        // "pi" => Token::Pi,
        "+" => Token::OpAdd,
        "-" => Token::OpSub,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "**" => Token::OpPow,
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
    }
}
