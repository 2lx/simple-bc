use super::terms::*;
use super::lexer::{Token, LexicalError};

grammar<'input>(input: &'input str);

// templates
SepVec<T, C>: Vec<T> = {
    <v:(<T> Repeated<C>)*> => v,
    <v:(<T> Repeated<C>)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

Repeated<C>: C = {
    <r:C> => r,
    Repeated<C> <r:C> => r,
}

// syntax
pub Source: Statements = {
    SepVec<Statement, ";"> => Statements(<>),
    Repeated<";"> <l:SepVec<Statement, ";">> => Statements(l),
}

Statement: Statement = {
    Expression => Statement(<>),
    Assignment => Statement(<>),
}

Assignment: Term = {
    <l:@L> "let" <v:Variable> "=" <e:Expression> <r:@R> => Term::Assignment(Loc(l, r), Box::new(v), Box::new(e)),
}

Expression: Term = {
    Expr0,
}

Expr0: Term = {
    <e1:Expr0> <l:@L> "+" <r:@R> <e2:Expr1> => Term::Add(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Expr0> <l:@L> "-" <r:@R> <e2:Expr1> => Term::Subtract(Loc(l, r), Box::new(e1), Box::new(e2)),
    Expr1,
}

Expr1: Term = {
    <e1:Expr1> <l:@L> "*" <r:@R> <e2:Expr2> => Term::Multiply(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Expr1> <l:@L> "/" <r:@R> <e2:Expr2> => Term::Divide(Loc(l, r), Box::new(e1), Box::new(e2)),
    Expr2,
}

Expr2: Term = {
    <e1:Expr2> <l:@L> "**" <r:@R> <e2:Expr3> => Term::Power(Loc(l, r), Box::new(e1), Box::new(e2)),
    Expr3,
}

Expr3: Term = {
    <l:@L> "-" <r:@R> <e:Expr3> => Term::UnaryMinus(Loc(l, r), Box::new(e)),
    <l:@L> <s:LexNumberLiteral> <r:@R> => Term::NumberLiteral(Loc(l, r), s.parse::<i128>().unwrap()),
    "(" <e:Expression> ")" => e,
    <l:@L> "PI" <r:@R> => Term::Pi(Loc(l, r)),
    Variable,
}

Variable: Term = {
    <l:@L> <s:LexVariable> <r:@R> => Term::Variable(Loc(l, r), s.to_string()),
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        LexVariable => Token::Variable(<&'input str>),
        LexNumberLiteral => Token::Number(<&'input str>),
        "PI" => Token::Pi,
        "let" => Token::Let,
        "+" => Token::OpAdd,
        "-" => Token::OpSub,
        "*" => Token::OpMul,
        "/" => Token::OpDiv,
        "**" => Token::OpPow,
        "(" => Token::OpenRoundBracket,
        ")" => Token::CloseRoundBracket,
        ";" => Token::Semicolon,
        "=" => Token::EqualsSign,
    }
}
